# 链接和加载

## 链接器/加载器的分工

链接器和加载器的基本工作都非常简单: **将更抽象的名字与更底层的名字绑定起来，也就是地址绑定**。比如:

- 它可以将程序员写的一个诸如`getline`的名字绑定到“iosys 模块内可执行代码的 612 字节处”

在有操作系统之前，一个程序可以支配机器所有的内存，由于知道计算机中所有的地址都是可用的，因此它能以固定的内存地址来汇编和链接.
有了操作系统以后，程序就必须和操作系统甚至其它程序共享计算机的内存。这意味着**在操作系统将程序加载到内存之前是无法确定程序运行的确切地址**的，并将最终的地址绑定从链接时推延到了加载时。

因此现在链接器和加载器有了明确的分工:

- **链接器对每一个程序的部分地址进行绑定并分配相对地址**
- **加载器完成最后的重定位步骤并赋予的实际地址**

## 链接过程

链接器将一系列的目标文件、库、及可能的命令文件作为它的输入，然后将输出的目标文件作为产品结果. 具体如下:
![Alt text](%E9%93%BE%E6%8E%A5%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%99%A8.assets/image.png)

- 每个输入文件都包含一系列的段(segments)，即会被连续存放在输出文件中的代码或数据块
- 每一个输入文件至少还包含一个符号表(symbol table), 分为
  - 导出符号: 当 i 请按文件定义, 其他文件中使用
  - 导入符号: 其他文件中定义, 当前文件使用

链接过程如下:

- **第一遍扫描**: 对输入文件进行扫描，得到各个段的大小，并收集对所有符号的定义和引用. 得到:
  - 段表: 包含输入文件中定义的所有段
  - 符号表: 包含所有导入/导出符号
- **第二遍扫描**:
  - 读取并重定位目标代码，为符号引用替换数字地址，根据反映重定位的段地址调整代码和数据的内存地址，并将重定位后的代码写入到输出文件中
  - 向输出文件中写入文件头部信息，重定位的段和符号表信息
